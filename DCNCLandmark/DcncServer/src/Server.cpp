// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "comm.hpp"
#include "gif2jpg.h"
#include "Server.h"
#include "CaffeClassify.h"
//#include "SentinelLDK.hpp"

#define MAX_THREAD_NUM 100

pthread_mutex_t ServiceMutex;

cv::Mat ImageExtend(cv::Mat src_mat);
void bufferDecode(const std::string image, std::vector<cv::Mat> &img_list);

static void* thread_classify(void *param)
{
    GPU_HANDLE *handle = (GPU_HANDLE*)param;
    
    std::string data_path = "./model";
    
    Classifier hclassify(handle->gpu_id, data_path);
    std::cout << "Init Model from " << data_path << std::endl;

    while (handle->brun)
    {
        pthread_mutex_lock(&handle->mutex);
        std::cout << "wait image at GPU ...\n";
        pthread_cond_wait(&handle->cond, &handle->mutex);
        if (!handle->image.empty())
        {
            handle->type.clear();
            handle->val.clear();
            handle->features.clear();
            
            std::cout << "GPU thread process ...\n";
            std::vector<Prediction> predictions;
            std::vector<float> features;
            
            //do {
                predictions = hclassify.Classify(handle->image, features);
            //} while (isnan(predictions[0].second));
            
            for (int i = 0; i < 3 && i < predictions.size(); i++)
            {
                handle->type.push_back(predictions[i].first);
                handle->val.push_back(predictions[i].second);
            }
            
            handle->features = features;
            
            handle->image.release();
        }
        pthread_mutex_unlock(&handle->mutex);
    }
    
    return ((void *)0);
}

ServiceHandler::ServiceHandler(int threadnum)
{
    if (threadnum > 0 && threadnum < MAX_THREAD_NUM)
    {
        google::InitGoogleLogging("TEST");
        fLI::FLAGS_stderrthreshold = google::WARNING;
        
        pthread_mutex_init(&ServiceMutex, NULL);
        
        m_threadnum = threadnum;
        
        m_halg = new GPU_HANDLE[m_threadnum];
        m_threadid = new unsigned long[m_threadnum];
        
        int max_id = -1, gpu_id = 0;
        for (int i = 0; i < m_threadnum; i++)
        {
            m_threadid[i] = 0;
            
            pthread_mutex_init(&m_halg[i].mutex, NULL);
            pthread_cond_init(&m_halg[i].cond, NULL);
            
            m_halg[i].brun = true;
            
#ifndef CPU_ONLY
            gpu_id = i;
            if (!Caffe::CheckDevice(gpu_id))
            {
                max_id = max_id == -1 ? gpu_id : max_id;
                gpu_id = gpu_id%max_id;
            }
#endif
            m_halg[i].gpu_id = gpu_id;
            int ret = pthread_create(&m_halg[i].thread, NULL, &thread_classify, &m_halg[i]);
            if (ret != 0)
            {
                std::cout << "Caffe thread create failed!!!" << std::endl;
                return;
            }
        }
    }
}

ServiceHandler::~ServiceHandler()
{
    if (m_threadnum > 0 && m_threadnum < MAX_THREAD_NUM)
    {
        for (int i = 0; i < m_threadnum; i++)
        {
            m_halg[i].brun = false;
        }
        
        delete [] m_halg;
        delete [] m_threadid;
        
        m_halg = NULL;
    }
}

void ServiceHandler::recognize_Image(RST_RCGZ& _return, const std::string& img)
{
    _return.bret = false;
    _return.type.clear();
    _return.val.clear();
    _return.features.clear();
    _return.message = "Failed";
    
    int index = get_ProcessID();
    
    if (index < 0 || index >= m_threadnum)
    {
        _return.message = "Thread Error";
        std::cout << "recognize_Image thread ID error!\n";
        
        return;
    }
    
    cv::Mat img_resize;
    std::vector<cv::Mat> img_list;
    GPU_HANDLE *phandle = &m_halg[index];
    
    std::cout << "recognize_Image ..." << std::endl;
    if (phandle != NULL && img.size() > 0)
    {
        bufferDecode(img, img_list);
        
        if (img_list.size() > 0)
        {
            /*float avg = 0;
            cv::Scalar scalar = cv::mean(img_list[0].clone());
            for (int i = 0; i < img_list[0].clone().channels(); i++)
            {
                avg += scalar[i];
            }
            avg /= img_list[0].clone().channels();
            if (avg < 30)
            {
                _return.val.push_back(1.0);
                _return.val.push_back(0);
                _return.val.push_back(0);
                _return.type.push_back("normal");
                _return.type.push_back("sexy");
                _return.type.push_back("pornographic");
            }*/
            
            long curtime = getCurrentTime();
            pthread_mutex_lock(&phandle->mutex);
            phandle->image = img_list[0].clone(); //ImageExtend(img_list[0].clone());
            pthread_cond_signal(&phandle->cond);
            std::cout << "send image to GPU ...\n";
            pthread_mutex_unlock(&phandle->mutex);
            
            bool bret = false;
            while (!bret)
            {
                usleep(2);
                pthread_mutex_lock(&phandle->mutex);
                if (phandle->image.empty())
                {
                    std::cout << "get GPU Feature ...\n";
                    _return.bret = true;
                    _return.val = phandle->val;
                    _return.type = phandle->type;
                    _return.message = "Success";
                    
                    for (int i = 0; i < phandle->features.size(); i++)
                    {
                        _return.features.push_back(phandle->features[i]);
                    }
                    
                    bret = true;
                }
                else
                {
                    pthread_cond_signal(&phandle->cond);
                    std::cout << "send signal to GPU ...\n";
                }
                pthread_mutex_unlock(&phandle->mutex);
            }
            
            printf("Get feature elapsed time is %ldms\n", getCurrentTime() - curtime);
        }
        else
        {
            _return.message = "Data Error";
            std::cout << "recognize_Image image data error\n";
        }
    }
    else
    {
        _return.message = "Handle or Data Error";
        std::cout << "recognize_Image handle error: " << img.size() << std::endl;
    }
}

void ServiceHandler::get_Feature(std::vector<double> & _return, const std::string& img)
{
}

int ServiceHandler::get_ProcessID()
{
    unsigned long id = (unsigned long)pthread_self();
    
    std::cout << "id: " << id << std::endl;
    
    int index;
    for (index = 0; index < m_threadnum; index++)
    {
        if (m_threadid[index] == id)
        {
            break;
        }
    }
    
    if (index >= m_threadnum)
    {
        pthread_mutex_lock(&ServiceMutex);
        for (index = 0; index < m_threadnum; index++)
        {
            if (m_threadid[index] == 0)
            {
                m_threadid[index] = id;
                break;
            }
        }
        pthread_mutex_unlock(&ServiceMutex);
    }
    
    return index;
}

void bufferDecode(const std::string image, std::vector<cv::Mat> &img_list)
{
    cv::Mat img_buff, img;
    
    img_list.clear();
    img_buff.create(1, (int)image.size(), CV_8UC1);
    memcpy(img_buff.data, image.data(), image.size());
    
    img = cv::imdecode(img_buff, cv::IMREAD_COLOR);
    
    if (!img.empty())
    {
        img_list.push_back(img.clone());
        img.release();
    }
    
    img_buff.release();
}

cv::Mat ImageExtend(cv::Mat src_mat)
{
    cv::Mat img_large, img_ROI, image;
    cv::Rect rectROI;
    
    if (src_mat.cols == src_mat.rows)
    {
        cv::resize(src_mat, image, cv::Size(256, 256));
    }
    else
    {
        int ch = src_mat.channels();
        int side_max = src_mat.cols > src_mat.rows ? src_mat.cols : src_mat.rows;
        img_large.create(side_max, side_max, CV_8UC(ch));
        
        memset(img_large.data, 255, img_large.cols*img_large.rows*ch*sizeof(uchar));
        
        rectROI.x = (img_large.cols - src_mat.cols)/2;
        rectROI.y = (img_large.rows - src_mat.rows)/2;
        rectROI.width = src_mat.cols;
        rectROI.height = src_mat.rows;
        
        img_ROI = img_large(rectROI);
        cv::addWeighted(img_ROI, 0, src_mat, 1, 0, img_ROI);
        
        cv::resize(img_large, image, cv::Size(256, 256));

        img_ROI.release();
        img_large.release();
    }
    
    return image.clone();
}

